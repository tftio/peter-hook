//! Git repository detection and utilities

use anyhow::{Context, Result};
use std::env;
use std::path::{Path, PathBuf};

/// Represents a git repository
#[derive(Debug, Clone)]
pub struct GitRepository {
    /// Path to the repository root (contains .git directory)
    pub root: PathBuf,
    /// Path to the .git directory
    pub git_dir: PathBuf,
    /// Path to the hooks directory
    pub hooks_dir: PathBuf,
}

impl GitRepository {
    /// Find and validate a git repository starting from the current directory
    ///
    /// # Errors
    ///
    /// Returns an error if no git repository is found or if the repository is invalid
    pub fn find_from_current_dir() -> Result<Self> {
        let current_dir = env::current_dir().context("Failed to get current working directory")?;

        Self::find_from_dir(&current_dir)
    }

    /// Find and validate a git repository starting from the specified directory
    ///
    /// # Errors
    ///
    /// Returns an error if no git repository is found or if the repository is invalid
    pub fn find_from_dir<P: AsRef<Path>>(start_dir: P) -> Result<Self> {
        let mut current = start_dir.as_ref();

        loop {
            let git_dir = current.join(".git");

            if git_dir.exists() {
                if git_dir.is_dir() {
                    // Standard .git directory
                    let hooks_dir = git_dir.join("hooks");
                    return Ok(Self {
                        root: current.to_path_buf(),
                        git_dir,
                        hooks_dir,
                    });
                } else if git_dir.is_file() {
                    // Git worktree or submodule - .git is a file pointing to actual .git directory
                    let git_content =
                        std::fs::read_to_string(&git_dir).context("Failed to read .git file")?;

                    if let Some(git_dir_line) = git_content
                        .lines()
                        .find(|line| line.starts_with("gitdir: "))
                    {
                        let git_path = git_dir_line
                            .strip_prefix("gitdir: ")
                            .context("Invalid gitdir format")?;

                        let actual_git_dir = if Path::new(git_path).is_absolute() {
                            PathBuf::from(git_path)
                        } else {
                            current.join(git_path)
                        };

                        if actual_git_dir.exists() && actual_git_dir.is_dir() {
                            let hooks_dir = actual_git_dir.join("hooks");
                            return Ok(Self {
                                root: current.to_path_buf(),
                                git_dir: actual_git_dir,
                                hooks_dir,
                            });
                        }
                    }
                }
            }

            match current.parent() {
                Some(parent) => current = parent,
                None => break,
            }
        }

        Err(anyhow::anyhow!(
            "No git repository found in {} or parent directories",
            start_dir.as_ref().display()
        ))
    }

    /// Check if the hooks directory exists, create if it doesn't
    ///
    /// # Errors
    ///
    /// Returns an error if the hooks directory cannot be created
    pub fn ensure_hooks_directory(&self) -> Result<()> {
        if !self.hooks_dir.exists() {
            std::fs::create_dir_all(&self.hooks_dir).with_context(|| {
                format!(
                    "Failed to create hooks directory: {}",
                    self.hooks_dir.display()
                )
            })?;
        }
        Ok(())
    }

    /// Get the path to a specific git hook
    #[must_use]
    pub fn hook_path(&self, hook_name: &str) -> PathBuf {
        self.hooks_dir.join(hook_name)
    }

    /// Check if a git hook already exists
    #[must_use]
    pub fn hook_exists(&self, hook_name: &str) -> bool {
        self.hook_path(hook_name).exists()
    }

    /// Get information about an existing hook
    ///
    /// # Errors
    ///
    /// Returns an error if the hook file cannot be read
    pub fn get_hook_info(&self, hook_name: &str) -> Result<Option<HookInfo>> {
        let hook_path = self.hook_path(hook_name);

        if !hook_path.exists() {
            return Ok(None);
        }

        let content = std::fs::read_to_string(&hook_path)
            .with_context(|| format!("Failed to read hook file: {}", hook_path.display()))?;

        let is_managed = content.contains("# Generated by peter-hook");
        let is_executable = {
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                let metadata =
                    std::fs::metadata(&hook_path).context("Failed to read hook file metadata")?;
                metadata.permissions().mode() & 0o111 != 0
            }
            #[cfg(not(unix))]
            {
                true // On Windows, assume executable
            }
        };

        Ok(Some(HookInfo {
            name: hook_name.to_string(),
            path: hook_path,
            is_managed,
            is_executable,
            content,
        }))
    }

    /// List all git hooks in the repository
    ///
    /// # Errors
    ///
    /// Returns an error if the hooks directory cannot be read
    pub fn list_hooks(&self) -> Result<Vec<String>> {
        if !self.hooks_dir.exists() {
            return Ok(Vec::new());
        }

        let mut hooks = Vec::new();

        for entry in std::fs::read_dir(&self.hooks_dir).with_context(|| {
            format!(
                "Failed to read hooks directory: {}",
                self.hooks_dir.display()
            )
        })? {
            let entry = entry.context("Failed to read directory entry")?;
            let path = entry.path();

            if path.is_file() {
                if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                    // Skip sample hooks and non-hook files
                    if !file_name.ends_with(".sample") && !file_name.starts_with('.') {
                        hooks.push(file_name.to_string());
                    }
                }
            }
        }

        hooks.sort();
        Ok(hooks)
    }
}

/// Information about an existing git hook
#[derive(Debug, Clone)]
pub struct HookInfo {
    /// Name of the hook (e.g., "pre-commit")
    pub name: String,
    /// Full path to the hook file
    pub path: PathBuf,
    /// Whether this hook was generated by peter-hook
    pub is_managed: bool,
    /// Whether the hook file is executable
    pub is_executable: bool,
    /// Content of the hook file
    pub content: String,
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn create_test_git_repo(temp_dir: &Path) -> PathBuf {
        let git_dir = temp_dir.join(".git");
        let hooks_dir = git_dir.join("hooks");
        std::fs::create_dir_all(&hooks_dir).unwrap();
        temp_dir.to_path_buf()
    }

    fn create_test_git_worktree(temp_dir: &Path, actual_git_dir: &Path) -> PathBuf {
        let git_file = temp_dir.join(".git");
        let git_content = format!("gitdir: {}", actual_git_dir.display());
        std::fs::write(&git_file, git_content).unwrap();
        temp_dir.to_path_buf()
    }

    #[test]
    fn test_find_repository_standard() {
        let temp_dir = TempDir::new().unwrap();
        let repo_dir = create_test_git_repo(temp_dir.path());

        let repo = GitRepository::find_from_dir(&repo_dir).unwrap();

        assert_eq!(repo.root, repo_dir);
        assert_eq!(repo.git_dir, repo_dir.join(".git"));
        assert_eq!(repo.hooks_dir, repo_dir.join(".git/hooks"));
    }

    #[test]
    fn test_find_repository_worktree() {
        let temp_dir = TempDir::new().unwrap();
        let actual_git_dir = temp_dir.path().join("actual-git");
        std::fs::create_dir_all(actual_git_dir.join("hooks")).unwrap();

        let worktree_dir = temp_dir.path().join("worktree");
        std::fs::create_dir_all(&worktree_dir).unwrap();
        let repo_dir = create_test_git_worktree(&worktree_dir, &actual_git_dir);

        let repo = GitRepository::find_from_dir(&repo_dir).unwrap();

        assert_eq!(repo.root, repo_dir);
        assert_eq!(repo.git_dir, actual_git_dir);
        assert_eq!(repo.hooks_dir, actual_git_dir.join("hooks"));
    }

    #[test]
    fn test_find_repository_nested() {
        let temp_dir = TempDir::new().unwrap();
        let repo_dir = create_test_git_repo(temp_dir.path());
        let nested_dir = repo_dir.join("src/deep/nested");
        std::fs::create_dir_all(&nested_dir).unwrap();

        let repo = GitRepository::find_from_dir(&nested_dir).unwrap();

        assert_eq!(repo.root, repo_dir);
    }

    #[test]
    fn test_no_repository() {
        let temp_dir = TempDir::new().unwrap();

        let result = GitRepository::find_from_dir(temp_dir.path());
        assert!(result.is_err());
    }

    #[test]
    fn test_hook_operations() {
        let temp_dir = TempDir::new().unwrap();
        let repo_dir = create_test_git_repo(temp_dir.path());
        let repo = GitRepository::find_from_dir(&repo_dir).unwrap();

        // Test hook doesn't exist initially
        assert!(!repo.hook_exists("pre-commit"));

        // Create a test hook
        let hook_content = "#!/bin/sh\necho 'test hook'\n";
        std::fs::write(repo.hook_path("pre-commit"), hook_content).unwrap();

        // Test hook exists now
        assert!(repo.hook_exists("pre-commit"));

        // Test hook info
        let info = repo.get_hook_info("pre-commit").unwrap().unwrap();
        assert_eq!(info.name, "pre-commit");
        assert!(!info.is_managed); // Not generated by our tool
        assert_eq!(info.content, hook_content);
    }

    #[test]
    fn test_list_hooks() {
        let temp_dir = TempDir::new().unwrap();
        let repo_dir = create_test_git_repo(temp_dir.path());
        let repo = GitRepository::find_from_dir(&repo_dir).unwrap();

        // Create some test hooks
        std::fs::write(repo.hook_path("pre-commit"), "#!/bin/sh\n").unwrap();
        std::fs::write(repo.hook_path("pre-push"), "#!/bin/sh\n").unwrap();
        std::fs::write(repo.hook_path("pre-commit.sample"), "sample").unwrap(); // Should be ignored

        let hooks = repo.list_hooks().unwrap();
        assert_eq!(hooks, vec!["pre-commit", "pre-push"]);
    }
}
