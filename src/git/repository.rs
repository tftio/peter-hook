//! Git repository detection and utilities

use anyhow::{Context, Result};
use git2::Repository as Git2Repository;
use std::{
    env,
    path::{Path, PathBuf},
};

/// Represents a git repository
#[derive(Debug, Clone)]
pub struct GitRepository {
    /// Path to the repository root (contains .git directory)
    pub root: PathBuf,
    /// Path to the .git directory
    pub git_dir: PathBuf,
    /// Path to the hooks directory
    pub hooks_dir: PathBuf,
    /// Whether this is a git worktree
    pub is_worktree: bool,
    /// Name of the worktree (None for main repository)
    pub worktree_name: Option<String>,
    /// Path to the common git directory (shared across worktrees)
    pub common_dir: PathBuf,
}

impl GitRepository {
    /// Find and validate a git repository starting from the current directory
    ///
    /// # Errors
    ///
    /// Returns an error if no git repository is found or if the repository is
    /// invalid
    pub fn find_from_current_dir() -> Result<Self> {
        let current_dir = env::current_dir().context("Failed to get current working directory")?;

        Self::find_from_dir(&current_dir)
    }

    /// Find and validate a git repository starting from the specified directory
    ///
    /// # Errors
    ///
    /// Returns an error if no git repository is found or if the repository is
    /// invalid
    pub fn find_from_dir<P: AsRef<Path>>(start_dir: P) -> Result<Self> {
        let start_dir = start_dir.as_ref();

        // Use git2 to discover and open the repository
        let git_repo = Git2Repository::discover(start_dir).with_context(|| {
            format!(
                "No git repository found in {} or parent directories",
                start_dir.display()
            )
        })?;

        let root = git_repo
            .workdir()
            .context("Repository has no working directory")?
            .to_path_buf();

        let git_dir = git_repo.path().to_path_buf();
        let is_worktree = git_repo.is_worktree();

        // Determine common directory and worktree name
        let (common_dir, worktree_name) = if is_worktree {
            // For worktrees, we need to find the common directory
            // In worktrees, the git_dir contains a path like: .git/worktrees/branch-name
            // The common directory is the parent's .git directory
            let common_dir = git_dir.parent().map_or_else(
                || git_dir.clone(),
                |parent| {
                    parent
                        .parent()
                        .map_or_else(|| git_dir.clone(), std::path::Path::to_path_buf)
                },
            );

            // Extract worktree name from the git directory path
            let worktree_name = git_dir
                .file_name()
                .and_then(|name| name.to_str())
                .map(ToString::to_string);

            (common_dir, worktree_name)
        } else {
            // For main repository, common_dir is the same as git_dir
            (git_dir.clone(), None)
        };

        // Determine hooks directory - use common_dir by default (shared hooks)
        let hooks_dir = common_dir.join("hooks");

        Ok(Self {
            root,
            git_dir,
            hooks_dir,
            is_worktree,
            worktree_name,
            common_dir,
        })
    }

    /// Check if the hooks directory exists, create if it doesn't
    ///
    /// # Errors
    ///
    /// Returns an error if the hooks directory cannot be created
    pub fn ensure_hooks_directory(&self) -> Result<()> {
        if !self.hooks_dir.exists() {
            std::fs::create_dir_all(&self.hooks_dir).with_context(|| {
                format!(
                    "Failed to create hooks directory: {}",
                    self.hooks_dir.display()
                )
            })?;
        }
        Ok(())
    }

    /// Get the path to a specific git hook
    #[must_use]
    pub fn hook_path(&self, hook_name: &str) -> PathBuf {
        self.hooks_dir.join(hook_name)
    }

    /// Check if a git hook already exists
    #[must_use]
    pub fn hook_exists(&self, hook_name: &str) -> bool {
        self.hook_path(hook_name).exists()
    }

    /// Get information about an existing hook
    ///
    /// # Errors
    ///
    /// Returns an error if the hook file cannot be read
    pub fn get_hook_info(&self, hook_name: &str) -> Result<Option<HookInfo>> {
        let hook_path = self.hook_path(hook_name);

        if !hook_path.exists() {
            return Ok(None);
        }

        let content = std::fs::read_to_string(&hook_path)
            .with_context(|| format!("Failed to read hook file: {}", hook_path.display()))?;

        let is_managed = content.contains("# Generated by peter-hook");
        let is_executable = {
            #[cfg(unix)]
            {
                use std::os::unix::fs::PermissionsExt;
                let metadata =
                    std::fs::metadata(&hook_path).context("Failed to read hook file metadata")?;
                metadata.permissions().mode() & 0o111 != 0
            }
            #[cfg(not(unix))]
            {
                true // On Windows, assume executable
            }
        };

        Ok(Some(HookInfo {
            name: hook_name.to_string(),
            path: hook_path,
            is_managed,
            is_executable,
            content,
        }))
    }

    /// List all git hooks in the repository
    ///
    /// # Errors
    ///
    /// Returns an error if the hooks directory cannot be read
    pub fn list_hooks(&self) -> Result<Vec<String>> {
        if !self.hooks_dir.exists() {
            return Ok(Vec::new());
        }

        let mut hooks = Vec::new();

        for entry in std::fs::read_dir(&self.hooks_dir).with_context(|| {
            format!(
                "Failed to read hooks directory: {}",
                self.hooks_dir.display()
            )
        })? {
            let entry = entry.context("Failed to read directory entry")?;
            let path = entry.path();

            if path.is_file() {
                if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                    // Skip sample hooks and non-hook files
                    if !file_name.ends_with(".sample") && !file_name.starts_with('.') {
                        hooks.push(file_name.to_string());
                    }
                }
            }
        }

        hooks.sort();
        Ok(hooks)
    }

    /// Check if this is the main repository (not a worktree)
    #[must_use]
    pub const fn is_main_worktree(&self) -> bool {
        !self.is_worktree
    }

    /// Get the worktree name if this is a worktree
    #[must_use]
    pub fn get_worktree_name(&self) -> Option<&str> {
        self.worktree_name.as_deref()
    }

    /// Get the path to the common hooks directory (shared across worktrees)
    #[must_use]
    #[allow(clippy::missing_const_for_fn)]
    pub fn get_common_hooks_dir(&self) -> &Path {
        &self.hooks_dir
    }

    /// Get the path where worktree-specific hooks would be stored
    #[must_use]
    pub fn get_worktree_hooks_dir(&self) -> PathBuf {
        if self.is_worktree {
            self.git_dir.join("hooks")
        } else {
            self.hooks_dir.clone()
        }
    }

    /// List all worktrees in this repository
    ///
    /// # Errors
    ///
    /// Returns an error if git operations fail
    pub fn list_worktrees(&self) -> Result<Vec<WorktreeInfo>> {
        let git_repo =
            Git2Repository::open(&self.common_dir).context("Failed to open git repository")?;

        let worktree_names = git_repo.worktrees().context("Failed to list worktrees")?;

        let mut worktrees = Vec::new();

        // Add main worktree info
        worktrees.push(WorktreeInfo {
            name: "main".to_string(),
            path: self
                .common_dir
                .parent()
                .unwrap_or(&self.common_dir)
                .to_path_buf(),
            is_main: true,
            is_current: !self.is_worktree,
        });

        // Add all other worktrees
        for name in worktree_names.iter().flatten() {
            if let Ok(worktree) = git_repo.find_worktree(name) {
                let path = worktree.path().to_path_buf();
                worktrees.push(WorktreeInfo {
                    name: name.to_string(),
                    path,
                    is_main: false,
                    is_current: self.worktree_name.as_deref() == Some(name),
                });
            }
        }

        Ok(worktrees)
    }
}

/// Information about an existing git hook
#[derive(Debug, Clone)]
pub struct HookInfo {
    /// Name of the hook (e.g., "pre-commit")
    pub name: String,
    /// Full path to the hook file
    pub path: PathBuf,
    /// Whether this hook was generated by peter-hook
    pub is_managed: bool,
    /// Whether the hook file is executable
    pub is_executable: bool,
    /// Content of the hook file
    pub content: String,
}

/// Information about a git worktree
#[derive(Debug, Clone)]
pub struct WorktreeInfo {
    /// Name of the worktree
    pub name: String,
    /// Path to the worktree directory
    pub path: PathBuf,
    /// Whether this is the main repository
    pub is_main: bool,
    /// Whether this is the current worktree
    pub is_current: bool,
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn create_test_git_repo(temp_dir: &Path) -> PathBuf {
        // Create a real git repository using git2
        Git2Repository::init(temp_dir).unwrap();
        temp_dir.to_path_buf()
    }

    #[test]
    fn test_find_repository_standard() {
        let temp_dir = TempDir::new().unwrap();
        let repo_dir = create_test_git_repo(temp_dir.path());

        let repo = GitRepository::find_from_dir(&repo_dir).unwrap();

        let expected_root = repo_dir.canonicalize().unwrap();
        let expected_git = repo_dir.join(".git").canonicalize().unwrap();
        let expected_hooks = repo_dir.join(".git/hooks").canonicalize().unwrap();
        assert_eq!(repo.root.canonicalize().unwrap(), expected_root);
        assert_eq!(repo.git_dir.canonicalize().unwrap(), expected_git);
        assert_eq!(repo.hooks_dir.canonicalize().unwrap(), expected_hooks);
        assert!(!repo.is_worktree);
        assert!(repo.worktree_name.is_none());
        assert_eq!(
            repo.common_dir.canonicalize().unwrap(),
            repo_dir.join(".git").canonicalize().unwrap()
        );
    }

    // TODO: Add proper worktree tests once git2 worktree creation is implemented
    // #[test]
    // fn test_find_repository_worktree() {
    //     // This would require creating actual worktrees with git2 API
    //     // For now, the worktree detection logic is tested manually
    // }

    #[test]
    fn test_find_repository_nested() {
        let temp_dir = TempDir::new().unwrap();
        let repo_dir = create_test_git_repo(temp_dir.path());
        let nested_dir = repo_dir.join("src/deep/nested");
        std::fs::create_dir_all(&nested_dir).unwrap();

        let repo = GitRepository::find_from_dir(&nested_dir).unwrap();

        assert_eq!(
            repo.root.canonicalize().unwrap(),
            repo_dir.canonicalize().unwrap()
        );
    }

    #[test]
    fn test_no_repository() {
        let temp_dir = TempDir::new().unwrap();

        let result = GitRepository::find_from_dir(temp_dir.path());
        assert!(result.is_err());
    }

    #[test]
    fn test_hook_operations() {
        let temp_dir = TempDir::new().unwrap();
        let repo_dir = create_test_git_repo(temp_dir.path());
        let repo = GitRepository::find_from_dir(&repo_dir).unwrap();

        // Test hook doesn't exist initially
        assert!(!repo.hook_exists("pre-commit"));

        // Create a test hook
        let hook_content = "#!/bin/sh\necho 'test hook'\n";
        std::fs::write(repo.hook_path("pre-commit"), hook_content).unwrap();

        // Test hook exists now
        assert!(repo.hook_exists("pre-commit"));

        // Test hook info
        let info = repo.get_hook_info("pre-commit").unwrap().unwrap();
        assert_eq!(info.name, "pre-commit");
        assert!(!info.is_managed); // Not generated by our tool
        assert_eq!(info.content, hook_content);
    }

    #[test]
    fn test_list_hooks() {
        let temp_dir = TempDir::new().unwrap();
        let repo_dir = create_test_git_repo(temp_dir.path());
        let repo = GitRepository::find_from_dir(&repo_dir).unwrap();

        // Create some test hooks
        std::fs::write(repo.hook_path("pre-commit"), "#!/bin/sh\n").unwrap();
        std::fs::write(repo.hook_path("pre-push"), "#!/bin/sh\n").unwrap();
        std::fs::write(repo.hook_path("pre-commit.sample"), "sample").unwrap(); // Should be ignored

        let hooks = repo.list_hooks().unwrap();
        assert_eq!(hooks, vec!["pre-commit", "pre-push"]);
    }
}
